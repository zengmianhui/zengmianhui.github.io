<!doctype html>



  


<html class="theme-next pisces use-motion">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css">


  <meta name="keywords" content="面试,java,">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1">






<meta name="description" content="文章转自：java面试题 Java面试宝典相关概念面向对象的三个特征封装,继承,多态.这个应该是人人皆知.有时候也会加上抽象. 多态的好处允许不同类对象对同一消息做出响应,即同一消息可以根据发送对象的不同而采用多种不同的行为方式(发送消息就是函数调用).主要有以下优点:  可替换性:多态对已存在代码具有可替换性. 可扩充性:增加新的子类不影响已经存在的类结构. 接口性:多态是超累通过方法签名,想子">
<meta name="keywords" content="面试,java">
<meta property="og:type" content="article">
<meta property="og:title" content="Java面试宝典">
<meta property="og:url" content="https://iszengmh.github.io/2017/02/20/Java面试宝典/index.html">
<meta property="og:site_name" content="Mr.zeng&#39;s personal blog">
<meta property="og:description" content="文章转自：java面试题 Java面试宝典相关概念面向对象的三个特征封装,继承,多态.这个应该是人人皆知.有时候也会加上抽象. 多态的好处允许不同类对象对同一消息做出响应,即同一消息可以根据发送对象的不同而采用多种不同的行为方式(发送消息就是函数调用).主要有以下优点:  可替换性:多态对已存在代码具有可替换性. 可扩充性:增加新的子类不影响已经存在的类结构. 接口性:多态是超累通过方法签名,想子">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://img.blog.csdn.net/20141105193133812?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGQ4NjQxNDAxMzA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center">
<meta property="og:updated_time" content="2020-05-02T07:29:21.096Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java面试宝典">
<meta name="twitter:description" content="文章转自：java面试题 Java面试宝典相关概念面向对象的三个特征封装,继承,多态.这个应该是人人皆知.有时候也会加上抽象. 多态的好处允许不同类对象对同一消息做出响应,即同一消息可以根据发送对象的不同而采用多种不同的行为方式(发送消息就是函数调用).主要有以下优点:  可替换性:多态对已存在代码具有可替换性. 可扩充性:增加新的子类不影响已经存在的类结构. 接口性:多态是超累通过方法签名,想子">
<meta name="twitter:image" content="http://img.blog.csdn.net/20141105193133812?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGQ4NjQxNDAxMzA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> Java面试宝典 | Mr.zeng's personal blog </title>
  <!-- 强制使用https访问 -->
  <script type="text/javascript">
    var host = "iszengmh.github.io";
    if ((host == window.location.host) && (window.location.protocol != "https:"))
        window.location.protocol = "https";
</script>
</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta custom-logo">
  

  <div class="custom-logo-site-title">
    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Mr.zeng's personal blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Java面试宝典
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-02-20T09:40:15+00:00" content="2017-02-20">
              2017-02-20
            </time>
          </span>

          
            <span class="post-category">
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope="" itemtype="https://schema.org/Thing">
                  <a href="/categories/面试/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope="" itemtype="https://schema.org/Thing">
                  <a href="/categories/面试/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          
             <span id="/2017/02/20/Java面试宝典/" class="leancloud_visitors" data-flag-title="Java面试宝典">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>文章转自：<br><a href="http://blog.csdn.net/dd864140130/article/details/55833087" target="_blank" rel="noopener">java面试题</a></p>
<h1 id="Java面试宝典"><a href="#Java面试宝典" class="headerlink" title="Java面试宝典"></a>Java面试宝典</h1><h1 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h1><h2 id="面向对象的三个特征"><a href="#面向对象的三个特征" class="headerlink" title="面向对象的三个特征"></a>面向对象的三个特征</h2><p>封装,继承,多态.这个应该是人人皆知.有时候也会加上抽象.</p>
<h2 id="多态的好处"><a href="#多态的好处" class="headerlink" title="多态的好处"></a>多态的好处</h2><p>允许不同类对象对同一消息做出响应,即同一消息可以根据发送对象的不同而采用多种不同的行为方式(发送消息就是函数调用).主要有以下优点:</p>
<ol>
<li>可替换性:多态对已存在代码具有可替换性.</li>
<li>可扩充性:增加新的子类不影响已经存在的类结构.</li>
<li>接口性:多态是超累通过方法签名,想子类提供一个公共接口,由子类来完善或者重写它来实现的.</li>
<li>灵活性:</li>
<li>简化性:</li>
</ol>
<h3 id="代码中如何实现多态"><a href="#代码中如何实现多态" class="headerlink" title="代码中如何实现多态"></a>代码中如何实现多态</h3><p>实现多态主要有以下三种方式:</p>
<ol>
<li>接口实现</li>
<li>继承父类重写方法</li>
<li>同一类中进行方法重载<a id="more"></a>
<h3 id="虚拟机是如何实现多态的"><a href="#虚拟机是如何实现多态的" class="headerlink" title="虚拟机是如何实现多态的"></a>虚拟机是如何实现多态的</h3>动态绑定技术(dynamic binding),执行期间判断所引用对象的实际类型,根据实际类型调用对应的方法.</li>
</ol>
<h2 id="接口的意义"><a href="#接口的意义" class="headerlink" title="接口的意义"></a>接口的意义</h2><p>接口的意义用三个词就可以概括:规范,扩展,回调.</p>
<h2 id="抽象类的意义"><a href="#抽象类的意义" class="headerlink" title="抽象类的意义"></a>抽象类的意义</h2><p>抽象类的意义可以用三句话来概括:</p>
<ol>
<li>为其他子类提供一个公共的类型</li>
<li>封装子类中重复定义的内容</li>
<li>定义抽象方法,子类虽然有不同的实现,但是定义时一致的<h2 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="headerlink" title="接口和抽象类的区别"></a>接口和抽象类的区别</h2></li>
</ol>
<table>
<thead>
<tr>
<th>比较</th>
<th>抽象类</th>
<th>接口</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认方法</td>
<td>抽象类可以有默认的方法实现</td>
<td>,java 8之前,接口中不存在方法的实现.</td>
</tr>
<tr>
<td>实现方式</td>
<td>子类使用extends关键字来继承抽象类.如果子类不是抽象类,子类需要提供抽象类中所声明方法的实现.</td>
<td>子类使用implements来实现接口,需要提供接口中所有声明的实现.</td>
</tr>
<tr>
<td>构造器</td>
<td>抽象类中可以有构造器,</td>
<td>接口中不能</td>
</tr>
<tr>
<td>和正常类区别</td>
<td>抽象类不能被实例化</td>
<td>接口则是完全不同的类型</td>
</tr>
<tr>
<td>访问修饰符</td>
<td>抽象方法可以有public,protected和default等修饰</td>
<td>接口默认是public,不能使用其他修饰符</td>
</tr>
<tr>
<td>多继承</td>
<td>一个子类只能存在一个父类</td>
<td>一个子类可以存在多个接口</td>
</tr>
<tr>
<td>添加新方法</td>
<td>想抽象类中添加新方法,可以提供默认的实现,因此可以不修改子类现有的代码</td>
<td>如果往接口中添加新方法,则子类中需要实现该方法.</td>
</tr>
<tr>
<td></td>
</tr>
</tbody>
</table>
<h2 id="父类的静态方法能否被子类重写"><a href="#父类的静态方法能否被子类重写" class="headerlink" title="父类的静态方法能否被子类重写"></a>父类的静态方法能否被子类重写</h2><p>不能.子类继承父类后,有相同的静态方法和非静态,这是非静态方法覆盖父类中的方法(即方法重写),父类的该静态方法被隐藏(如果对象是父类则调用该隐藏的方法),另外子类可集成父类的静态与非静态方法,至于方法重载我觉得它其中一要素就是在同一类中,不能说父类中的什么方法与子类里的什么方法是方法重载的体现.</p>
<h2 id="什么是不可变对象"><a href="#什么是不可变对象" class="headerlink" title="什么是不可变对象"></a>什么是不可变对象</h2><p>不可变对象指对象一旦被创建，状态就不能再改变。任何修改都会创建一个新的对象，如 String、Integer及其它包装类。</p>
<h2 id="能否创建一个包含可变对象的不可变对象"><a href="#能否创建一个包含可变对象的不可变对象" class="headerlink" title="能否创建一个包含可变对象的不可变对象?"></a>能否创建一个包含可变对象的不可变对象?</h2><p>当然可以创建一个包含可变对象的不可变对象的，你只需要谨慎一点，不要共享可变对象的引用就可以了，如果需要变化时，就返回原对象的一个拷贝。最常见的例子就是对象中包含一个日期对象的引用.</p>
<h2 id="java-创建对象的几种方式"><a href="#java-创建对象的几种方式" class="headerlink" title="java 创建对象的几种方式"></a>java 创建对象的几种方式</h2><ol>
<li>采用new</li>
<li>通过反射</li>
<li>采用clone</li>
<li>通过序列化机制</li>
</ol>
<p>前2者都需要显式地调用构造方法.   造成耦合性最高的恰好是第一种,因此你发现无论什么框架,只要涉及到解耦必先减少new的使用.</p>
<h2 id="switch中能否使用string做参数"><a href="#switch中能否使用string做参数" class="headerlink" title="switch中能否使用string做参数"></a>switch中能否使用string做参数</h2><p>在idk 1.7之前,switch只能支持byte,short,char,int或者其对应的封装类以及Enum类型。从idk 1.7之后switch开始支持String.</p>
<h2 id="Object中有哪些公共方法"><a href="#Object中有哪些公共方法" class="headerlink" title="Object中有哪些公共方法?"></a>Object中有哪些公共方法?</h2><ol>
<li><code>equals()</code></li>
<li><code>clone()</code></li>
<li><code>getClass()</code></li>
<li><code>notify(),notifyAll(),wait()</code></li>
</ol>
<h2 id="java当中的四种引用"><a href="#java当中的四种引用" class="headerlink" title="java当中的四种引用"></a>java当中的四种引用</h2><p>强引用,软引用,弱引用,虚引用.不同的引用类型主要体现在GC上:</p>
<ol>
<li>强引用：如果一个对象具有强引用，它就不会被垃圾回收器回收。即使当前内存空间不足，JVM也不会回收它，而是抛出 OutOfMemoryError 错误，使程序异常终止。如果想中断强引用和某个对象之间的关联，可以显式地将引用赋值为null，这样一来的话，JVM在合适的时间就会回收该对象</li>
<li>软引用：在使用软引用时，如果内存的空间足够，软引用就能继续被使用，而不会被垃圾回收器回收，只有在内存不足时，软引用才会被垃圾回收器回收。</li>
<li>弱引用：具有弱引用的对象拥有的生命周期更短暂。因为当 JVM 进行垃圾回收，一旦发现弱引用对象，无论当前内存空间是否充足，都会将弱引用回收。不过由于垃圾回收器是一个优先级较低的线程，所以并不一定能迅速发现弱引用对象</li>
<li>虚引用：顾名思义，就是形同虚设，如果一个对象仅持有虚引用，那么它相当于没有引用，在任何时候都可能被垃圾回收器回收。</li>
</ol>
<p>更多了解参见<a href="http://blog.csdn.net/dd864140130/article/details/49885811" target="_blank" rel="noopener">深入对象引用</a></p>
<h2 id="WeakReference与SoftReference的区别"><a href="#WeakReference与SoftReference的区别" class="headerlink" title="WeakReference与SoftReference的区别?"></a>WeakReference与SoftReference的区别?</h2><p>这点在四种引用类型中已经做了解释,这里简单说明一下即可:<br>虽然 WeakReference 与 SoftReference 都有利于提高 GC 和 内存的效率，但是 WeakReference ，一旦失去最后一个强引用，就会被 GC 回收，而软引用虽然不能阻止被回收，但是可以延迟到 JVM 内存不足的时候。</p>
<h2 id="为什么要有不同的引用类型"><a href="#为什么要有不同的引用类型" class="headerlink" title="为什么要有不同的引用类型"></a>为什么要有不同的引用类型</h2><p>不像C语言,我们可以控制内存的申请和释放,在Java中有时候我们需要适当的控制对象被回收的时机,因此就诞生了不同的引用类型,可以说不同的引用类型实则是对GC回收时机不可控的妥协.有以下几个使用场景可以充分的说明:</p>
<ol>
<li>利用软引用和弱引用解决OOM问题：用一个HashMap来保存图片的路径和相应图片对象关联的软引用之间的映射关系，在内存不足时，JVM会自动回收这些缓存图片对象所占用的空间，从而有效地避免了OOM的问题.</li>
<li>通过软引用实现Java对象的高速缓存:比如我们创建了一Person的类，如果每次需要查询一个人的信息,哪怕是几秒中之前刚刚查询过的，都要重新构建一个实例，这将引起大量Person对象的消耗,并且由于这些对象的生命周期相对较短,会引起多次GC影响性能。此时,通过软引用和 HashMap 的结合可以构建高速缓存,提供性能.</li>
</ol>
<h2 id="java中-和eqauls-的区别-equals-和-hashcode的区别"><a href="#java中-和eqauls-的区别-equals-和-hashcode的区别" class="headerlink" title="java中==和eqauls()的区别,equals()和`hashcode的区别"></a>java中==和<code>eqauls()</code>的区别,<code>equals()</code>和`hashcode的区别</h2><p>==是运算符,用于比较两个变量是否相等,而equals是Object类的方法,用于比较两个对象是否相等.默认Object类的equals方法是比较两个对象的地址,此时和==的结果一样.换句话说:基本类型比较用==,比较的是他们的值.默认下,对象用==比较时,比较的是内存地址,如果需要比较对象内容,需要重写equal方法</p>
<p>##<code>equals()</code>和<code>hashcode()</code>的联系<br><code>hashCode()</code>是Object类的一个方法,返回一个哈希值.如果两个对象根据equal()方法比较相等,那么调用这两个对象中任意一个对象的hashCode()方法必须产生相同的哈希值.<br>如果两个对象根据eqaul()方法比较不相等,那么产生的哈希值不一定相等(碰撞的情况下还是会相等的.)</p>
<h2 id="a-hashCode-有什么用-与a-equals-b-有什么关系"><a href="#a-hashCode-有什么用-与a-equals-b-有什么关系" class="headerlink" title="a.hashCode()有什么用?与a.equals(b)有什么关系"></a>a.hashCode()有什么用?与a.equals(b)有什么关系</h2><p>hashCode() 方法是相应对象整型的 hash 值。它常用于基于 hash 的集合类，如 Hashtable、HashMap、LinkedHashMap等等。它与 equals() 方法关系特别紧密。根据 Java 规范，两个使用 equal() 方法来判断相等的对象，必须具有相同的 hashcode。</p>
<p>将对象放入到集合中时,首先判断要放入对象的hashcode是否已经在集合中存在,不存在则直接放入集合.如果hashcode相等,然后通过equal()方法判断要放入对象与集合中的任意对象是否相等:如果equal()判断不相等,直接将该元素放入集合中,否则不放入.</p>
<h2 id="有没有可能两个不相等的对象有相同的hashcode"><a href="#有没有可能两个不相等的对象有相同的hashcode" class="headerlink" title="有没有可能两个不相等的对象有相同的hashcode"></a>有没有可能两个不相等的对象有相同的hashcode</h2><p>有可能，两个不相等的对象可能会有相同的 hashcode 值，这就是为什么在 hashmap 中会有冲突。相等 hashcode 值的规定只是说如果两个对象相等，必须有相同的hashcode 值，但是没有关于不相等对象的任何规定。</p>
<h2 id="可以在hashcode中使用随机数字吗"><a href="#可以在hashcode中使用随机数字吗" class="headerlink" title="可以在hashcode中使用随机数字吗?"></a>可以在hashcode中使用随机数字吗?</h2><p>不行，因为同一对象的 hashcode 值必须是相同的</p>
<h2 id="“a-b”与a-equals-b-有什么区别"><a href="#“a-b”与a-equals-b-有什么区别" class="headerlink" title="“a==b”与a.equals(b)有什么区别"></a>“a==b”与a.equals(b)有什么区别</h2><p>如果a 和b 都是对象，则 a==b 是比较两个对象的引用，只有当 a 和 b 指向的是堆中的同一个对象才会返回 true，而 a.equals(b) 是进行逻辑比较，所以通常需要重写该方法来提供逻辑一致性的比较。例如，String 类重写 equals() 方法，所以可以用于两个不同对象，但是包含的字母相同的比较。</p>
<h2 id="3-0-1-0-3返回值是什么"><a href="#3-0-1-0-3返回值是什么" class="headerlink" title="3*0.1==0.3返回值是什么"></a><code>3*0.1==0.3</code>返回值是什么</h2><p>false，因为有些浮点数不能完全精确的表示出来。</p>
<h2 id="a-a-b与a-b有什么区别吗"><a href="#a-a-b与a-b有什么区别吗" class="headerlink" title="a=a+b与a+=b有什么区别吗?"></a>a=a+b与a+=b有什么区别吗?</h2><p>隐式的将加操作的结果类型强制转换为持有结果的类型。如果两这个整型相加，如 byte、short 或者 int，首先会将它们提升到 int 类型，然后在执行加法操作。如果加法操作的结果比 a 的最大值要大，则 a+b 会出现编译错误，但是 a += b 没问题，如下：<br>byte a = 127;<br>byte b = 127;<br>b = a + b; // error : cannot convert from int to byte<br>b += a; // ok<br>（译者注：这个地方应该表述的有误，其实无论 a+b 的值为多少，编译器都会报错，因为 a+b 操作会将 a、b 提升为 int 类型，所以将 int 类型赋值给 byte 就会编译出错）</p>
<h2 id="内部类的作用"><a href="#内部类的作用" class="headerlink" title="内部类的作用"></a>内部类的作用</h2><p>内部类可以用多个实例,每个实例都有自己的状态信息,并且与其他外围对象的信息相互独立.在单个外围类当中,可以让多个内部类以不同的方式实现同一接口,或者继承同一个类.创建内部类对象的时刻病不依赖于外部类对象的创建.内部类并没有令人疑惑的”is-a”关系,它就像是一个独立的实体.</p>
<p>内部类提供了更好的封装,除了该外围类,其他类都不能访问</p>
<h2 id="final-finalize和finally的不同之处"><a href="#final-finalize和finally的不同之处" class="headerlink" title="final,finalize和finally的不同之处"></a>final,finalize和finally的不同之处</h2><p>final 是一个修饰符，可以修饰变量、方法和类。如果 final 修饰变量，意味着该变量的值在初始化后不能被改变。finalize 方法是在对象被回收之前调用的方法，给对象自己最后一个复活的机会，但是什么时候调用 finalize 没有保证。finally 是一个关键字，与 try 和 catch 一起用于异常的处理。finally 块一定会被执行，无论在 try 块中是否有发生异常。</p>
<h2 id="clone-是哪个类型的方法"><a href="#clone-是哪个类型的方法" class="headerlink" title="clone()是哪个类型的方法?"></a>clone()是哪个类型的方法?</h2><p>java.lang.Cloneable 是一个标示性接口，不包含任何方法，clone 方法在 object 类中定义。并且需要知道 clone() 方法是一个本地方法，这意味着它是由 c 或 c++ 或 其他本地语言实现的。</p>
<h2 id="深拷贝和浅拷贝的区别是什么"><a href="#深拷贝和浅拷贝的区别是什么" class="headerlink" title="深拷贝和浅拷贝的区别是什么?"></a>深拷贝和浅拷贝的区别是什么?</h2><p>浅拷贝：被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。换言之，浅拷贝仅仅复制所考虑的对象，而不复制它所引用的对象。</p>
<p>深拷贝：被复制对象的所有变量都含有与原来的对象相同的值，而那些引用其他对象的变量将指向被复制过的新对象，而不再是原有的那些被引用的对象。换言之，深拷贝把要复制的对象所引用的对象都复制了一遍。</p>
<h2 id="static都有哪些用法"><a href="#static都有哪些用法" class="headerlink" title="static都有哪些用法?"></a>static都有哪些用法?</h2><p>几乎所有的人都知道static关键字这两个基本的用法:静态变量和静态方法.也就是被static所修饰的变量/方法都属于类的静态资源,类实例所共享.</p>
<p>除了静态变量和静态方法之外,static也用于静态块,多用于初始化操作:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> calss PreCache&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="comment">//执行相关操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此外static也多用于修饰内部类,此时称之为静态内部类.</p>
<p>最后一种用法就是静态导包,即<code>import static</code>.import static是在JDK 1.5之后引入的新特性,可以用来指定导入某个类中的静态资源,并且不需要使用类名.资源名,可以直接使用资源名,比如:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//System.out.println(Math.sin(20));传统做法</span></span><br><span class="line">        System.out.println(sin(<span class="number">20</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="final有哪些用法"><a href="#final有哪些用法" class="headerlink" title="final有哪些用法"></a>final有哪些用法</h2><p>final也是很多面试喜欢问的地方,能回答下以下三点就不错了:<br>1.被final修饰的类不可以被继承<br>2.被final修饰的方法不可以被重写<br>3.被final修饰的变量不可以被改变.如果修饰的引用,那么表示引用不可变,引用指向的内容可变.<br>4.被final修饰的方法,JVM会尝试将其内联,以提高运行效率<br>5.被final修饰的常量,在编译阶段会存入常量池中.</p>
<p>当前回答出编译器对final域要遵守的两个重排序规则更好:<br>1.在构造函数内对一个final域的写入,与随后把这个被构造对象的引用赋值给一个引用变量,这两个操作之间不能重排序.<br>2.初次读一个包含final域的对象的引用,与随后初次读这个final域,这两个操作之间不能重排序.</p>
<hr>
<p>#数据类型相关</p>
<h2 id="java中int-char-long各占多少字节"><a href="#java中int-char-long各占多少字节" class="headerlink" title="java中int char,long各占多少字节?"></a>java中int char,long各占多少字节?</h2><table>
<thead>
<tr>
<th>类型</th>
<th>位数</th>
<th>字节数</th>
</tr>
</thead>
<tbody>
<tr>
<td>short</td>
<td>2</td>
<td>16</td>
</tr>
<tr>
<td>int</td>
<td>4</td>
<td>32</td>
</tr>
<tr>
<td>long</td>
<td>8</td>
<td>64</td>
</tr>
<tr>
<td>float</td>
<td>4</td>
<td>32</td>
</tr>
<tr>
<td>double</td>
<td>8</td>
<td>64</td>
</tr>
<tr>
<td>char</td>
<td>2</td>
<td>16</td>
</tr>
</tbody>
</table>
<h2 id="64位的JVM当中-int的长度是多少"><a href="#64位的JVM当中-int的长度是多少" class="headerlink" title="64位的JVM当中,int的长度是多少?"></a>64位的JVM当中,int的长度是多少?</h2><p>Java 中，int 类型变量的长度是一个固定值，与平台无关，都是 32 位。意思就是说，在 32 位 和 64 位 的Java 虚拟机中，int 类型的长度是相同的。</p>
<h2 id="java-int和Integer的区别"><a href="#java-int和Integer的区别" class="headerlink" title="java int和Integer的区别"></a>java int和Integer的区别</h2><p>Integer是int的包装类型,在拆箱和装箱中,而知自动转换.int是基本类型，直接存数值，而integer是对象，用一个引用指向这个对象.</p>
<h2 id="int-和Integer谁占用的内存更多"><a href="#int-和Integer谁占用的内存更多" class="headerlink" title="int 和Integer谁占用的内存更多?"></a>int 和Integer谁占用的内存更多?</h2><p>Integer 对象会占用更多的内存。Integer是一个对象，需要存储对象的元数据。但是 int 是一个原始类型的数据，所以占用的空间更少。</p>
<h2 id="String-StringBuffer和StringBuilder区别"><a href="#String-StringBuffer和StringBuilder区别" class="headerlink" title="String,StringBuffer和StringBuilder区别"></a>String,StringBuffer和StringBuilder区别</h2><p>String是字符串常量,final修饰;StringBuffer字符串变量(线程安全);<br>StringBuilder 字符串变量(线程不安全).</p>
<h3 id="String和StringBuffer"><a href="#String和StringBuffer" class="headerlink" title="String和StringBuffer"></a>String和StringBuffer</h3><p>String和StringBuffer主要区别是性能:String是不可变对象,每次对String类型进行操作都等同于产生了一个新的String对象,然后指向新的String对象.所以尽量不在对String进行大量的拼接操作,否则会产生很多临时对象,导致GC开始工作,影响系统性能.</p>
<p>StringBuffer是对对象本身操作,而不是产生新的对象,因此在通常在有大量拼接的情况下我们建议使用StringBuffer.</p>
<p>但是需要注意现在JVM会对String拼接做一定的优化:<br><code>String s=“This is only ”+”simple”+”test”</code>会被虚拟机直接优化成<code>String s=“This is only simple test”</code>,此时就不存在拼接过程.</p>
<h3 id="StringBuffer和StringBuilder"><a href="#StringBuffer和StringBuilder" class="headerlink" title="StringBuffer和StringBuilder"></a>StringBuffer和StringBuilder</h3><p>StringBuffer是线程安全的可变字符串,其内部实现是可变数组.StringBuilder是java 5.0新增的,其功能和StringBuffer类似,但是非线程安全.因此,在没有多线程问题的前提下,使用StringBuilder会取得更好的性能.</p>
<h2 id="什么是编译器常量-使用它有什么风险"><a href="#什么是编译器常量-使用它有什么风险" class="headerlink" title="什么是编译器常量?使用它有什么风险?"></a>什么是编译器常量?使用它有什么风险?</h2><p>公共静态不可变（public static final ）变量也就是我们所说的编译期常量，这里的 public 可选的。实际上这些变量在编译时会被替换掉，因为编译器知道这些变量的值，并且知道这些变量在运行时不能改变。这种方式存在的一个问题是你使用了一个内部的或第三方库中的公有编译时常量，但是这个值后面被其他人改变了，但是你的客户端仍然在使用老的值，甚至你已经部署了一个新的jar。为了避免这种情况，当你在更新依赖 JAR 文件时，确保重新编译你的程序。</p>
<h2 id="java当中使用什么类型表示价格比较好"><a href="#java当中使用什么类型表示价格比较好" class="headerlink" title="java当中使用什么类型表示价格比较好?"></a>java当中使用什么类型表示价格比较好?</h2><p>如果不是特别关心内存和性能的话，使用BigDecimal，否则使用预定义精度的 double 类型。</p>
<h2 id="如何将byte转为String"><a href="#如何将byte转为String" class="headerlink" title="如何将byte转为String"></a>如何将byte转为String</h2><p>可以使用 String 接收 byte[] 参数的构造器来进行转换，需要注意的点是要使用的正确的编码，否则会使用平台默认编码，这个编码可能跟原来的编码相同，也可能不同。</p>
<h2 id="可以将int强转为byte类型么-会产生什么问题"><a href="#可以将int强转为byte类型么-会产生什么问题" class="headerlink" title="可以将int强转为byte类型么?会产生什么问题?"></a>可以将int强转为byte类型么?会产生什么问题?</h2><p>我们可以做强制转换，但是Java中int是32位的而byte是8 位的，所以,如果强制转化int类型的高24位将会被丢弃，byte 类型的范围是从-128.到128</p>
<hr>
<h2 id="关于垃圾回收"><a href="#关于垃圾回收" class="headerlink" title="关于垃圾回收"></a>关于垃圾回收</h2><h2 id="你知道哪些垃圾回收算法"><a href="#你知道哪些垃圾回收算法" class="headerlink" title="你知道哪些垃圾回收算法?"></a>你知道哪些垃圾回收算法?</h2><p>垃圾回收从理论上非常容易理解,具体的方法有以下几种:</p>
<ol>
<li>标记-清除</li>
<li>标记-复制</li>
<li>标记-整理</li>
<li>分代回收<br>更详细的内容参见<a href="http://blog.csdn.net/dd864140130/article/details/50084471" target="_blank" rel="noopener">深入理解垃圾回收算法</a></li>
</ol>
<p>##如何判断一个对象是否应该被回收<br>这就是所谓的对象存活性判断,常用的方法有两种:1.引用计数法;2:对象可达性分析.由于引用计数法存在互相引用导致无法进行GC的问题,所以目前JVM虚拟机多使用对象可达性分析算法.</p>
<p>##简单的解释一下垃圾回收<br>Java 垃圾回收机制最基本的做法是分代回收。内存中的区域被划分成不同的世代，对象根据其存活的时间被保存在对应世代的区域中。一般的实现是划分成3个世代：年轻、年老和永久。内存的分配是发生在年轻世代中的。当一个对象存活时间足够长的时候，它就会被复制到年老世代中。对于不同的世代可以使用不同的垃圾回收算法。进行世代划分的出发点是对应用中对象存活时间进行研究之后得出的统计规律。一般来说，一个应用中的大部分对象的存活时间都很短。比如局部变量的存活时间就只在方法的执行过程中。基于这一点，对于年轻世代的垃圾回收算法就可以很有针对性.</p>
<h2 id="调用System-gc-会发生什么"><a href="#调用System-gc-会发生什么" class="headerlink" title="调用System.gc()会发生什么?"></a>调用System.gc()会发生什么?</h2><p>通知GC开始工作,但是GC真正开始的时间不确定.</p>
<hr>
<h1 id="进程-线程相关"><a href="#进程-线程相关" class="headerlink" title="进程,线程相关"></a>进程,线程相关</h1><h2 id="说说进程-线程-协程之间的区别"><a href="#说说进程-线程-协程之间的区别" class="headerlink" title="说说进程,线程,协程之间的区别"></a>说说进程,线程,协程之间的区别</h2><p>简而言之,进程是程序运行和资源分配的基本单位,一个程序至少有一个进程,一个进程至少有一个线程.进程在执行过程中拥有独立的内存单元,而多个线程共享内存资源,减少切换次数,从而效率更高.线程是进程的一个实体,是cpu调度和分派的基本单位,是比程序更小的能独立运行的基本单位.同一进程中的多个线程之间可以并发执行.</p>
<h2 id="你了解守护线程吗-它和非守护线程有什么区别"><a href="#你了解守护线程吗-它和非守护线程有什么区别" class="headerlink" title="你了解守护线程吗?它和非守护线程有什么区别"></a>你了解守护线程吗?它和非守护线程有什么区别</h2><p>程序运行完毕,jvm会等待非守护线程完成后关闭,但是jvm不会等待守护线程.守护线程最典型的例子就是GC线程</p>
<h2 id="什么是多线程上下文切换"><a href="#什么是多线程上下文切换" class="headerlink" title="什么是多线程上下文切换"></a>什么是多线程上下文切换</h2><p>多线程的上下文切换是指CPU控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取CPU执行权的线程的过程。</p>
<h2 id="创建两种线程的方式-他们有什么区别"><a href="#创建两种线程的方式-他们有什么区别" class="headerlink" title="创建两种线程的方式?他们有什么区别?"></a>创建两种线程的方式?他们有什么区别?</h2><p>通过实现java.lang.Runnable或者通过扩展java.lang.Thread类.相比扩展Thread,实现Runnable接口可能更优.原因有二:</p>
<ol>
<li>Java不支持多继承.因此扩展Thread类就代表这个子类不能扩展其他类.而实现Runnable接口的类还可能扩展另一个类.</li>
<li>类可能只要求可执行即可,因此集成整个Thread类的开销过大.</li>
</ol>
<h2 id="Runnable和Callable的区别"><a href="#Runnable和Callable的区别" class="headerlink" title="Runnable和Callable的区别"></a>Runnable和Callable的区别</h2><p>Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。<br>这其实是很有用的一个特性，因为多线程相比单线程更难、更复杂的一个重要原因就是因为多线程充满着未知性，某条线程是否执行了？某条线程执行了多久？某条线程执行的时候我们期望的数据是否已经赋值完毕？无法得知，我们能做的只是等待这条多线程的任务执行完毕而已。而Callable+Future/FutureTask却可以获取多线程运行的结果，可以在等待时间太长没获取到需要的数据的情况下取消该线程的任务，真的是非常有用。</p>
<h2 id="什么导致线程阻塞"><a href="#什么导致线程阻塞" class="headerlink" title="什么导致线程阻塞"></a>什么导致线程阻塞</h2><p>阻塞指的是暂停一个线程的执行以等待某个条件发生（如某资源就绪），学过操作系统的同学对它一定已经很熟悉了。Java 提供了大量方法来支持阻塞，下面让我们逐一分析。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>sleep()</td>
<td>sleep() 允许 指定以毫秒为单位的一段时间作为参数，它使得线程在指定的时间内进入阻塞状态，不能得到CPU 时间，指定的时间一过，线程重新进入可执行状态。 典型地，sleep() 被用在等待某个资源就绪的情形：测试发现条件不满足后，让线程阻塞一段时间后重新测试，直到条件满足为止</td>
</tr>
<tr>
<td>suspend() 和 resume()</td>
<td>两个方法配套使用，suspend()使得线程进入阻塞状态，并且不会自动恢复，必须其对应的resume() 被调用，才能使得线程重新进入可执行状态。典型地，suspend() 和 resume() 被用在等待另一个线程产生的结果的情形：测试发现结果还没有产生后，让线程阻塞，另一个线程产生了结果后，调用 resume() 使其恢复。</td>
</tr>
<tr>
<td>yield()</td>
<td>yield() 使得线程放弃当前分得的 CPU 时间，但是不使线程阻塞，即线程仍处于可执行状态，随时可能再次分得 CPU 时间。调用 yield() 的效果等价于调度程序认为该线程已执行了足够的时间从而转到另一个线程</td>
</tr>
<tr>
<td>wait() 和 notify()</td>
<td>两个方法配套使用，wait() 使得线程进入阻塞状态，它有两种形式，一种允许 指定以毫秒为单位的一段时间作为参数，另一种没有参数，前者当对应的 notify() 被调用或者超出指定时间时线程重新进入可执行状态，后者则必须对应的 notify() 被调用.</td>
</tr>
</tbody>
</table>
<h2 id="wait-notify-和suspend-resume-之间的区别"><a href="#wait-notify-和suspend-resume-之间的区别" class="headerlink" title="wait(),notify()和suspend(),resume()之间的区别"></a>wait(),notify()和suspend(),resume()之间的区别</h2><p>初看起来它们与 suspend() 和 resume() 方法对没有什么分别，但是事实上它们是截然不同的。区别的核心在于，前面叙述的所有方法，阻塞时都不会释放占用的锁（如果占用了的话），而这一对方法则相反。上述的核心区别导致了一系列的细节上的区别。</p>
<p>首先，前面叙述的所有方法都隶属于 Thread 类，但是这一对却直接隶属于 Object 类，也就是说，所有对象都拥有这一对方法。初看起来这十分不可思议，但是实际上却是很自然的，因为这一对方法阻塞时要释放占用的锁，而锁是任何对象都具有的，调用任意对象的 wait() 方法导致线程阻塞，并且该对象上的锁被释放。而调用 任意对象的notify()方法则导致因调用该对象的 wait() 方法而阻塞的线程中随机选择的一个解除阻塞（但要等到获得锁后才真正可执行）。</p>
<p>其次，前面叙述的所有方法都可在任何位置调用，但是这一对方法却必须在 synchronized 方法或块中调用，理由也很简单，只有在synchronized 方法或块中当前线程才占有锁，才有锁可以释放。同样的道理，调用这一对方法的对象上的锁必须为当前线程所拥有，这样才有锁可以释放。因此，这一对方法调用必须放置在这样的 synchronized 方法或块中，该方法或块的上锁对象就是调用这一对方法的对象。若不满足这一条件，则程序虽然仍能编译，但在运行时会出现IllegalMonitorStateException 异常。</p>
<p>wait() 和 notify() 方法的上述特性决定了它们经常和synchronized 方法或块一起使用，将它们和操作系统的进程间通信机制作一个比较就会发现它们的相似性：synchronized方法或块提供了类似于操作系统原语的功能，它们的执行不会受到多线程机制的干扰，而这一对方法则相当于 block 和wakeup 原语（这一对方法均声明为 synchronized）。它们的结合使得我们可以实现操作系统上一系列精妙的进程间通信的算法（如信号量算法），并用于解决各种复杂的线程间通信问题。</p>
<p>关于 wait() 和 notify() 方法最后再说明两点：<br>第一：调用 notify() 方法导致解除阻塞的线程是从因调用该对象的 wait() 方法而阻塞的线程中随机选取的，我们无法预料哪一个线程将会被选择，所以编程时要特别小心，避免因这种不确定性而产生问题。</p>
<p>第二：除了 notify()，还有一个方法 notifyAll() 也可起到类似作用，唯一的区别在于，调用 notifyAll() 方法将把因调用该对象的 wait() 方法而阻塞的所有线程一次性全部解除阻塞。当然，只有获得锁的那一个线程才能进入可执行状态。</p>
<p>谈到阻塞，就不能不谈一谈死锁，略一分析就能发现，suspend() 方法和不指定超时期限的 wait() 方法的调用都可能产生死锁。遗憾的是，Java 并不在语言级别上支持死锁的避免，我们在编程中必须小心地避免死锁。</p>
<p>以上我们对 Java 中实现线程阻塞的各种方法作了一番分析，我们重点分析了 wait() 和 notify() 方法，因为它们的功能最强大，使用也最灵活，但是这也导致了它们的效率较低，较容易出错。实际使用中我们应该灵活使用各种方法，以便更好地达到我们的目的。</p>
<h2 id="为什么wait-方法和notify-notifyAll-方法要在同步块中被调用"><a href="#为什么wait-方法和notify-notifyAll-方法要在同步块中被调用" class="headerlink" title="为什么wait()方法和notify()/notifyAll()方法要在同步块中被调用"></a>为什么wait()方法和notify()/notifyAll()方法要在同步块中被调用</h2><p>这是JDK强制的，wait()方法和notify()/notifyAll()方法在调用前都必须先获得对象的锁</p>
<h2 id="wait-方法和notify-notifyAll-方法在放弃对象监视器时有什么区别"><a href="#wait-方法和notify-notifyAll-方法在放弃对象监视器时有什么区别" class="headerlink" title="wait()方法和notify()/notifyAll()方法在放弃对象监视器时有什么区别"></a>wait()方法和notify()/notifyAll()方法在放弃对象监视器时有什么区别</h2><p>wait()方法和notify()/notifyAll()方法在放弃对象监视器的时候的区别在于：wait()方法立即释放对象监视器，notify()/notifyAll()方法则会等待线程剩余代码执行完毕才会放弃对象监视器。</p>
<h2 id="wait-与sleep-的区别"><a href="#wait-与sleep-的区别" class="headerlink" title="wait()与sleep()的区别"></a>wait()与sleep()的区别</h2><p> 关于这两者已经在上面进行详细的说明,这里就做个概括好了:</p>
<ul>
<li>sleep()来自Thread类，和wait()来自Object类.调用sleep()方法的过程中，线程不会释放对象锁。而 调用 wait 方法线程会释放对象锁</li>
<li>sleep()睡眠后不出让系统资源，wait让其他线程可以占用CPU</li>
<li>sleep(milliseconds)需要指定一个睡眠时间，时间一到会自动唤醒.而wait()需要配合notify()或者notifyAll()使用</li>
</ul>
<h2 id="synchronized和ReentrantLock的区别"><a href="#synchronized和ReentrantLock的区别" class="headerlink" title="synchronized和ReentrantLock的区别"></a>synchronized和ReentrantLock的区别</h2><p>synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上：<br>（1）ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁<br>（2）ReentrantLock可以获取各种锁的信息<br>（3）ReentrantLock可以灵活地实现多路通知<br>另外，二者的锁机制其实也是不一样的:ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word.</p>
<h2 id="FutureTask是什么"><a href="#FutureTask是什么" class="headerlink" title="FutureTask是什么"></a>FutureTask是什么</h2><p>这个其实前面有提到过，FutureTask表示一个异步运算的任务。FutureTask里面可以传入一个Callable的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。当然，由于FutureTask也是Runnable接口的实现类，所以FutureTask也可以放入线程池中。</p>
<h2 id="一个线程如果出现了运行时异常怎么办"><a href="#一个线程如果出现了运行时异常怎么办" class="headerlink" title="一个线程如果出现了运行时异常怎么办?"></a>一个线程如果出现了运行时异常怎么办?</h2><p>如果这个异常没有被捕获的话，这个线程就停止执行了。另外重要的一点是：如果这个线程持有某个某个对象的监视器，那么这个对象监视器会被立即释放</p>
<h2 id="如何在两个线程间共享数据"><a href="#如何在两个线程间共享数据" class="headerlink" title="如何在两个线程间共享数据"></a>如何在两个线程间共享数据</h2><p>通过在线程之间共享对象就可以了，然后通过wait/notify/notifyAll、await/signal/signalAll进行唤起和等待，比方说阻塞队列BlockingQueue就是为线程之间共享数据而设计的</p>
<h2 id="如何正确的使用wait-使用if还是while"><a href="#如何正确的使用wait-使用if还是while" class="headerlink" title="如何正确的使用wait()?使用if还是while?"></a>如何正确的使用wait()?使用if还是while?</h2><p>wait() 方法应该在循环调用，因为当线程获取到 CPU 开始执行的时候，其他条件可能还没有满足，所以在处理前，循环检测条件是否满足会更好。下面是一段标准的使用 wait 和 notify 方法的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">synchronized (obj) &#123;</span><br><span class="line">   while (condition does not hold)</span><br><span class="line">     obj.wait(); // (Releases lock, and reacquires on wakeup)</span><br><span class="line">     ... // Perform action appropriate to condition</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="什么是线程局部变量"><a href="#什么是线程局部变量" class="headerlink" title="什么是线程局部变量"></a>什么是线程局部变量</h2><p>线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java提供ThreadLocal类来支持线程局部变量，是一种实现线程安全的方式。但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。</p>
<h2 id="ThreadLoal的作用是什么"><a href="#ThreadLoal的作用是什么" class="headerlink" title="ThreadLoal的作用是什么?"></a>ThreadLoal的作用是什么?</h2><p>简单说ThreadLocal就是一种以空间换时间的做法在每个Thread里面维护了一个ThreadLocal.ThreadLocalMap把数据进行隔离，数据不共享，自然就没有线程安全方面的问题了.</p>
<h2 id="生产者消费者模型的作用是什么"><a href="#生产者消费者模型的作用是什么" class="headerlink" title="生产者消费者模型的作用是什么?"></a>生产者消费者模型的作用是什么?</h2><p>（1）通过平衡生产者的生产能力和消费者的消费能力来提升整个系统的运行效率，这是生产者消费者模型最重要的作用<br>（2）解耦，这是生产者消费者模型附带的作用，解耦意味着生产者和消费者之间的联系少，联系越少越可以独自发展而不需要收到相互的制约</p>
<h2 id="写一个生产者-消费者队列"><a href="#写一个生产者-消费者队列" class="headerlink" title="写一个生产者-消费者队列"></a>写一个生产者-消费者队列</h2><p>可以通过阻塞队列实现,也可以通过wait-notify来实现.</p>
<h3 id="使用阻塞队列来实现"><a href="#使用阻塞队列来实现" class="headerlink" title="使用阻塞队列来实现"></a>使用阻塞队列来实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">//消费者</span><br><span class="line">public class Producer implements Runnable&#123;</span><br><span class="line">    private final BlockingQueue&lt;Integer&gt; queue;</span><br><span class="line"></span><br><span class="line">    public Producer(BlockingQueue q)&#123;</span><br><span class="line">        this.queue=q;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            while (true)&#123;</span><br><span class="line">                Thread.sleep(1000);//模拟耗时</span><br><span class="line">                queue.put(produce());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch (InterruptedException e)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int produce() &#123;</span><br><span class="line">        int n=new Random().nextInt(10000);</span><br><span class="line">        System.out.println(&quot;Thread:&quot; + Thread.currentThread().getId() + &quot; produce:&quot; + n);</span><br><span class="line">        return n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//消费者</span><br><span class="line">public class Consumer implements Runnable &#123;</span><br><span class="line">    private final BlockingQueue&lt;Integer&gt; queue;</span><br><span class="line"></span><br><span class="line">    public Consumer(BlockingQueue q)&#123;</span><br><span class="line">        this.queue=q;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (true)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(2000);//模拟耗时</span><br><span class="line">                consume(queue.take());</span><br><span class="line">            &#125;catch (InterruptedException e)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void consume(Integer n) &#123;</span><br><span class="line">        System.out.println(&quot;Thread:&quot; + Thread.currentThread().getId() + &quot; consume:&quot; + n);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//测试</span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        BlockingQueue&lt;Integer&gt; queue=new ArrayBlockingQueue&lt;Integer&gt;(100);</span><br><span class="line">        Producer p=new Producer(queue);</span><br><span class="line">        Consumer c1=new Consumer(queue);</span><br><span class="line">        Consumer c2=new Consumer(queue);</span><br><span class="line"></span><br><span class="line">        new Thread(p).start();</span><br><span class="line">        new Thread(c1).start();</span><br><span class="line">        new Thread(c2).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用wait-notify来实现"><a href="#使用wait-notify来实现" class="headerlink" title="使用wait-notify来实现"></a>使用wait-notify来实现</h3><p>该种方式应该最经典,这里就不做说明了</p>
<h2 id="ConcurrentHashMap的并发度是什么"><a href="#ConcurrentHashMap的并发度是什么" class="headerlink" title="ConcurrentHashMap的并发度是什么?"></a>ConcurrentHashMap的并发度是什么?</h2><p>ConcurrentHashMap的并发度就是segment的大小，默认为16，这意味着最多同时可以有16条线程操作ConcurrentHashMap，这也是ConcurrentHashMap对Hashtable的最大优势，任何情况下，Hashtable能同时有两条线程获取Hashtable中的数据吗？</p>
<h2 id="CyclicBarrier和CountDownLatch区别"><a href="#CyclicBarrier和CountDownLatch区别" class="headerlink" title="CyclicBarrier和CountDownLatch区别"></a>CyclicBarrier和CountDownLatch区别</h2><p>这两个类非常类似，都在java.util.concurrent下，都可以用来表示代码运行到某个点上，二者的区别在于：</p>
<ul>
<li>CyclicBarrier的某个线程运行到某个点上之后，该线程即停止运行，直到所有的线程都到达了这个点，所有线程才重新运行；CountDownLatch则不是，某线程运行到某个点上之后，只是给某个数值-1而已，该线程继续运行</li>
<li>CyclicBarrier只能唤起一个任务，CountDownLatch可以唤起多个任务</li>
<li>CyclicBarrier可重用，CountDownLatch不可重用，计数值为0该CountDownLatch就不可再用了</li>
</ul>
<h2 id="java中的-操作符线程安全么"><a href="#java中的-操作符线程安全么" class="headerlink" title="java中的++操作符线程安全么?"></a>java中的++操作符线程安全么?</h2><p>不是线程安全的操作。它涉及到多个指令，如读取变量值，增加，然后存储回内存，这个过程可能会出现多个线程交差</p>
<h2 id="你有哪些多线程开发良好的实践"><a href="#你有哪些多线程开发良好的实践" class="headerlink" title="你有哪些多线程开发良好的实践?"></a>你有哪些多线程开发良好的实践?</h2><ol>
<li>给线程命名</li>
<li>最小化同步范围</li>
<li>优先使用volatile</li>
<li>尽可能使用更高层次的并发工具而非wait和notify()来实现线程通信,如BlockingQueue,Semeaphore</li>
<li>优先使用并发容器而非同步容器.</li>
<li>考虑使用线程池</li>
</ol>
<hr>
<p>#关于volatile关键字</p>
<h2 id="可以创建Volatile数组吗"><a href="#可以创建Volatile数组吗" class="headerlink" title="可以创建Volatile数组吗?"></a>可以创建Volatile数组吗?</h2><p>Java 中可以创建 volatile类型数组，不过只是一个指向数组的引用，而不是整个数组。如果改变引用指向的数组，将会受到volatile 的保护，但是如果多个线程同时改变数组的元素，volatile标示符就不能起到之前的保护作用了</p>
<h2 id="volatile能使得一个非原子操作变成原子操作吗"><a href="#volatile能使得一个非原子操作变成原子操作吗" class="headerlink" title="volatile能使得一个非原子操作变成原子操作吗?"></a>volatile能使得一个非原子操作变成原子操作吗?</h2><p>一个典型的例子是在类中有一个 long 类型的成员变量。如果你知道该成员变量会被多个线程访问，如计数器、价格等，你最好是将其设置为 volatile。为什么？因为 Java 中读取 long 类型变量不是原子的，需要分成两步，如果一个线程正在修改该 long 变量的值，另一个线程可能只能看到该值的一半（前 32 位）。但是对一个 volatile 型的 long 或 double 变量的读写是原子。</p>
<p>一种实践是用 volatile 修饰 long 和 double 变量，使其能按原子类型来读写。double 和 long 都是64位宽，因此对这两种类型的读是分为两部分的，第一次读取第一个 32 位，然后再读剩下的 32 位，这个过程不是原子的，但 Java 中 volatile 型的 long 或 double 变量的读写是原子的。volatile 修复符的另一个作用是提供内存屏障（memory barrier），例如在分布式框架中的应用。简单的说，就是当你写一个 volatile 变量之前，Java 内存模型会插入一个写屏障（write barrier），读一个 volatile 变量之前，会插入一个读屏障（read barrier）。意思就是说，在你写一个 volatile 域时，能保证任何线程都能看到你写的值，同时，在写之前，也能保证任何数值的更新对所有线程是可见的，因为内存屏障会将其他所有写的值更新到缓存。</p>
<h2 id="volatile类型变量提供什么保证"><a href="#volatile类型变量提供什么保证" class="headerlink" title="volatile类型变量提供什么保证?"></a>volatile类型变量提供什么保证?</h2><p>volatile 主要有两方面的作用:1.避免指令重排2.可见性保证.例如，JVM 或者 JIT为了获得更好的性能会对语句重排序，但是 volatile 类型变量即使在没有同步块的情况下赋值也不会与其他语句重排序。 volatile 提供 happens-before 的保证，确保一个线程的修改能对其他线程是可见的。某些情况下，volatile 还能提供原子性，如读 64 位数据类型，像 long 和 double 都不是原子的(低32位和高32位)，但 volatile 类型的 double 和 long 就是原子的.</p>
<hr>
<p>#关于集合</p>
<h2 id="Java中的集合及其继承关系"><a href="#Java中的集合及其继承关系" class="headerlink" title="Java中的集合及其继承关系"></a>Java中的集合及其继承关系</h2><p>关于集合的体系是每个人都应该烂熟于心的,尤其是对我们经常使用的List,Map的原理更该如此.这里我们看这张图即可:<br><img src="http://img.blog.csdn.net/20141105193133812?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGQ4NjQxNDAxMzA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="这里写图片描述"></p>
<p>更多内容可见<a href="http://write.blog.csdn.net/postedit/40826423" target="_blank" rel="noopener">集合类总结</a></p>
<h2 id="poll-方法和remove-方法区别"><a href="#poll-方法和remove-方法区别" class="headerlink" title="poll()方法和remove()方法区别?"></a>poll()方法和remove()方法区别?</h2><p>poll() 和 remove() 都是从队列中取出一个元素，但是 poll() 在获取元素失败的时候会返回空，但是 remove() 失败的时候会抛出异常。</p>
<h2 id="LinkedHashMap和PriorityQueue的区别"><a href="#LinkedHashMap和PriorityQueue的区别" class="headerlink" title="LinkedHashMap和PriorityQueue的区别"></a>LinkedHashMap和PriorityQueue的区别</h2><p>PriorityQueue 是一个优先级队列,保证最高或者最低优先级的的元素总是在队列头部，但是 LinkedHashMap 维持的顺序是元素插入的顺序。当遍历一个 PriorityQueue 时，没有任何顺序保证，但是 LinkedHashMap 课保证遍历顺序是元素插入的顺序。</p>
<h2 id="WeakHashMap与HashMap的区别是什么"><a href="#WeakHashMap与HashMap的区别是什么" class="headerlink" title="WeakHashMap与HashMap的区别是什么?"></a>WeakHashMap与HashMap的区别是什么?</h2><p>WeakHashMap 的工作与正常的 HashMap 类似，但是使用弱引用作为 key，意思就是当 key 对象没有任何引用时，key/value 将会被回收。</p>
<h2 id="ArrayList和LinkedList的区别"><a href="#ArrayList和LinkedList的区别" class="headerlink" title="ArrayList和LinkedList的区别?"></a>ArrayList和LinkedList的区别?</h2><p>最明显的区别是 ArrrayList底层的数据结构是数组，支持随机访问，而 LinkedList 的底层数据结构是双向循环链表，不支持随机访问。使用下标访问一个元素，ArrayList 的时间复杂度是 O(1)，而 LinkedList 是 O(n)。</p>
<h2 id="ArrayList和HashMap默认大小"><a href="#ArrayList和HashMap默认大小" class="headerlink" title="ArrayList和HashMap默认大小?"></a>ArrayList和HashMap默认大小?</h2><p>在 Java 7 中，ArrayList 的默认大小是 10 个元素，HashMap 的默认大小是16个元素（必须是2的幂）。这就是 Java 7 中 ArrayList 和 HashMap 类的代码片段<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private static final int DEFAULT_CAPACITY = 10;</span><br><span class="line"> </span><br><span class="line"> //from HashMap.java JDK 7</span><br><span class="line"> static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16</span><br></pre></td></tr></table></figure></p>
<h2 id="Comparator和Comparable的区别"><a href="#Comparator和Comparable的区别" class="headerlink" title="Comparator和Comparable的区别?"></a>Comparator和Comparable的区别?</h2><p>Comparable 接口用于定义对象的自然顺序，而 comparator 通常用于定义用户定制的顺序。Comparable 总是只有一个，但是可以有多个 comparator 来定义对象的顺序。</p>
<h2 id="如何实现集合排序"><a href="#如何实现集合排序" class="headerlink" title="如何实现集合排序?"></a>如何实现集合排序?</h2><p>你可以使用有序集合，如 TreeSet 或 TreeMap，你也可以使用有顺序的的集合，如 list，然后通过 Collections.sort() 来排序。</p>
<h2 id="如何打印数组内容"><a href="#如何打印数组内容" class="headerlink" title="如何打印数组内容"></a>如何打印数组内容</h2><p>你可以使用 Arrays.toString() 和 Arrays.deepToString() 方法来打印数组。由于数组没有实现 toString() 方法，所以如果将数组传递给 System.out.println() 方法，将无法打印出数组的内容，但是 Arrays.toString() 可以打印每个元素。</p>
<h2 id="LinkedList的是单向链表还是双向"><a href="#LinkedList的是单向链表还是双向" class="headerlink" title="LinkedList的是单向链表还是双向?"></a>LinkedList的是单向链表还是双向?</h2><p>双向循环列表,具体实现自行查阅源码.</p>
<h2 id="TreeMap是实现原理"><a href="#TreeMap是实现原理" class="headerlink" title="TreeMap是实现原理"></a>TreeMap是实现原理</h2><p>采用红黑树实现,具体实现自行查阅源码.</p>
<h2 id="遍历ArrayList时如何正确移除一个元素"><a href="#遍历ArrayList时如何正确移除一个元素" class="headerlink" title="遍历ArrayList时如何正确移除一个元素"></a>遍历ArrayList时如何正确移除一个元素</h2><p>该问题的关键在于面试者使用的是 ArrayList 的 remove() 还是 Iterator 的 remove()方法。这有一段示例代码，是使用正确的方式来实现在遍历的过程中移除元素，而不会出现 ConcurrentModificationException 异常的示例代码。</p>
<h2 id="什么是ArrayMap-它和HashMap有什么区别"><a href="#什么是ArrayMap-它和HashMap有什么区别" class="headerlink" title="什么是ArrayMap?它和HashMap有什么区别?"></a>什么是ArrayMap?它和HashMap有什么区别?</h2><p>ArrayMap是Android SDK中提供的,非Android开发者可以略过.<br>ArrayMap是用两个数组来模拟map,更少的内存占用空间,更高的效率.<br>具体参考这篇文章:<a href="http://lvable.com/?p=217%5D" target="_blank" rel="noopener">ArrayMap VS HashMap</a></p>
<h2 id="HashMap的实现原理"><a href="#HashMap的实现原理" class="headerlink" title="HashMap的实现原理"></a>HashMap的实现原理</h2><p>1   HashMap概述：  HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。<br>2   HashMap的数据结构： 在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。</p>
<p>当我们往Hashmap中put元素时,首先根据key的hashcode重新计算hash值,根绝hash值得到这个元素在数组中的位置(下标),如果该数组在该位置上已经存放了其他元素,那么在这个位置上的元素将以链表的形式存放,新加入的放在链头,最先加入的放入链尾.如果数组中该位置没有元素,就直接将该元素放到数组的该位置上.</p>
<h2 id="你了解Fail-Fast机制吗"><a href="#你了解Fail-Fast机制吗" class="headerlink" title="你了解Fail-Fast机制吗"></a>你了解Fail-Fast机制吗</h2><p>Fail-Fast即我们常说的快速失败,更多内容参看<a href="http://blog.csdn.net/chenssy/article/details/38151189" target="_blank" rel="noopener">fail-fast机制</a></p>
<hr>
<h1 id="关于日期"><a href="#关于日期" class="headerlink" title="关于日期"></a>关于日期</h1><h2 id="SimpleDateFormat是线程安全的吗"><a href="#SimpleDateFormat是线程安全的吗" class="headerlink" title="SimpleDateFormat是线程安全的吗?"></a>SimpleDateFormat是线程安全的吗?</h2><p>非常不幸，DateFormat 的所有实现，包括 SimpleDateFormat 都不是线程安全的，因此你不应该在多线程序中使用，除非是在对外线程安全的环境中使用，如 将 SimpleDateFormat 限制在 ThreadLocal 中。如果你不这么做，在解析或者格式化日期的时候，可能会获取到一个不正确的结果。因此，从日期、时间处理的所有实践来说，我强力推荐 joda-time 库。</p>
<h2 id="如何格式化日期"><a href="#如何格式化日期" class="headerlink" title="如何格式化日期?"></a>如何格式化日期?</h2><p>Java 中，可以使用 SimpleDateFormat 类或者 joda-time 库来格式日期。DateFormat 类允许你使用多种流行的格式来格式化日期。参见答案中的示例代码，代码中演示了将日期格式化成不同的格式，如 dd-MM-yyyy 或 ddMMyyyy。</p>
<hr>
<h1 id="关于异常"><a href="#关于异常" class="headerlink" title="关于异常"></a>关于异常</h1><h2 id="简单描述java异常体系"><a href="#简单描述java异常体系" class="headerlink" title="简单描述java异常体系"></a>简单描述java异常体系</h2><p>相比没有人不了解异常体系,关于异常体系的更多信息可以见:<a href="http://blog.csdn.net/dd864140130/article/details/42504189" target="_blank" rel="noopener">白话异常机制</a></p>
<h2 id="什么是异常链"><a href="#什么是异常链" class="headerlink" title="什么是异常链"></a>什么是异常链</h2><p>详情直接参见<a href="http://blog.csdn.net/dd864140130/article/details/42504189" target="_blank" rel="noopener">白话异常机制</a>,不做解释了.</p>
<h2 id="throw和throws的区别"><a href="#throw和throws的区别" class="headerlink" title="throw和throws的区别"></a>throw和throws的区别</h2><p>throw用于主动抛出java.lang.Throwable 类的一个实例化对象，意思是说你可以通过关键字 throw 抛出一个 Error 或者 一个Exception，如：<code>throw new IllegalArgumentException(“size must be multiple of 2″)</code>,<br>而throws 的作用是作为方法声明和签名的一部分，方法被抛出相应的异常以便调用者能处理。Java 中，任何未处理的受检查异常强制在 throws 子句中声明。</p>
<hr>
<h2 id="关于序列化"><a href="#关于序列化" class="headerlink" title="关于序列化"></a>关于序列化</h2><h2 id="Java-中，Serializable-与-Externalizable-的区别"><a href="#Java-中，Serializable-与-Externalizable-的区别" class="headerlink" title="Java 中，Serializable 与 Externalizable 的区别"></a>Java 中，Serializable 与 Externalizable 的区别</h2><p>Serializable 接口是一个序列化 Java 类的接口，以便于它们可以在网络上传输或者可以将它们的状态保存在磁盘上，是 JVM 内嵌的默认序列化方式，成本高、脆弱而且不安全。Externalizable 允许你控制整个序列化过程，指定特定的二进制格式，增加安全机制。</p>
<hr>
<p>#关于JVM</p>
<h2 id="JVM特性"><a href="#JVM特性" class="headerlink" title="JVM特性"></a>JVM特性</h2><p>平台无关性.<br>Java语言的一个非常重要的特点就是与平台的无关性。而使用Java虚拟机是实现这一特点的关键。一般的高级语言如果要在不同的平台上运行，至少需要编译成不同的目标代码。而引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用模式Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。</p>
<h2 id="简单解释一下类加载器"><a href="#简单解释一下类加载器" class="headerlink" title="简单解释一下类加载器"></a>简单解释一下类加载器</h2><p>有关类加载器一般会问你四种类加载器的应用场景以及双亲委派模型,更多的内容参看<a href="http://blog.csdn.net/dd864140130/article/details/49817357" target="_blank" rel="noopener">深入理解JVM加载器</a></p>
<h2 id="简述堆和栈的区别"><a href="#简述堆和栈的区别" class="headerlink" title="简述堆和栈的区别"></a>简述堆和栈的区别</h2><p>VM 中堆和栈属于不同的内存区域，使用目的也不同。栈常用于保存方法帧和局部变量，而对象总是在堆上分配。栈通常都比堆小，也不会在多个线程之间共享，而堆被整个 JVM 的所有线程共享。</p>
<h2 id="简述JVM内存分配"><a href="#简述JVM内存分配" class="headerlink" title="简述JVM内存分配"></a>简述JVM内存分配</h2><ol>
<li>基本数据类型比变量和对象的引用都是在栈分配的</li>
<li>堆内存用来存放由new创建的对象和数组</li>
<li>类变量（static修饰的变量），程序在一加载的时候就在堆中为类变量分配内存，堆中的内存地址存放在栈中</li>
<li>实例变量：当你使用java关键字new的时候，系统在堆中开辟并不一定是连续的空间分配给变量，是根据零散的堆内存地址，通过哈希算法换算为一长串数字以表征这个变量在堆中的”物理位置”,实例变量的生命周期–当实例变量的引用丢失后，将被GC（垃圾回收器）列入可回收“名单”中，但并不是马上就释放堆中内存</li>
<li>局部变量: 由声明在某方法，或某代码段里（比如for循环），执行到它的时候在栈中开辟内存，当局部变量一但脱离作用域，内存立即释放</li>
</ol>
<hr>
<p>#其他</p>
<h2 id="java当中采用的是大端还是小端"><a href="#java当中采用的是大端还是小端" class="headerlink" title="java当中采用的是大端还是小端?"></a>java当中采用的是大端还是小端?</h2><h2 id="XML解析的几种方式和特点"><a href="#XML解析的几种方式和特点" class="headerlink" title="XML解析的几种方式和特点"></a>XML解析的几种方式和特点</h2><p>DOM,SAX,PULL三种解析方式:</p>
<ul>
<li>DOM:消耗内存：先把xml文档都读到内存中，然后再用DOM API来访问树形结构，并获取数据。这个写起来很简单，但是很消耗内存。要是数据过大，手机不够牛逼，可能手机直接死机</li>
<li>SAX:解析效率高，占用内存少，基于事件驱动的：更加简单地说就是对文档进行顺序扫描，当扫描到文档(document)开始与结束、元素(element)开始与结束、文档(document)结束等地方时通知事件处理函数，由事件处理函数做相应动作，然后继续同样的扫描，直至文档结束。</li>
<li>PULL:与 SAX 类似，也是基于事件驱动，我们可以调用它的next（）方法，来获取下一个解析事件（就是开始文档，结束文档，开始标签，结束标签），当处于某个元素时可以调用XmlPullParser的getAttributte()方法来获取属性的值，也可调用它的nextText()获取本节点的值。</li>
</ul>
<h2 id="JDK-1-7特性"><a href="#JDK-1-7特性" class="headerlink" title="JDK 1.7特性"></a>JDK 1.7特性</h2><p>然 JDK 1.7 不像 JDK 5 和 8 一样的大版本，但是，还是有很多新的特性，如 try-with-resource 语句，这样你在使用流或者资源的时候，就不需要手动关闭，Java 会自动关闭。Fork-Join 池某种程度上实现 Java 版的 Map-reduce。允许 Switch 中有 String 变量和文本。菱形操作符(\&lt;>)用于类型推断，不再需要在变量声明的右边申明泛型，因此可以写出可读写更强、更简洁的代码</p>
<h2 id="JDK-1-8特性"><a href="#JDK-1-8特性" class="headerlink" title="JDK 1.8特性"></a>JDK 1.8特性</h2><p>java 8 在 Java 历史上是一个开创新的版本，下面 JDK 8 中 5 个主要的特性：<br>Lambda 表达式，允许像对象一样传递匿名函数<br>Stream API，充分利用现代多核 CPU，可以写出很简洁的代码<br>Date 与 Time API，最终，有一个稳定、简单的日期和时间库可供你使用<br>扩展方法，现在，接口中可以有静态、默认方法。<br>重复注解，现在你可以将相同的注解在同一类型上使用多次。</p>
<h2 id="Maven和ANT有什么区别"><a href="#Maven和ANT有什么区别" class="headerlink" title="Maven和ANT有什么区别?"></a>Maven和ANT有什么区别?</h2><p>虽然两者都是构建工具，都用于创建 Java 应用，但是 Maven 做的事情更多，在基于“约定优于配置”的概念下，提供标准的Java 项目结构，同时能为应用自动管理依赖（应用中所依赖的 JAR 文件），Maven 与 ANT 工具更多的不同之处请参见答案。<br>这就是所有的面试题，如此之多，是不是？我可以保证，如果你能回答列表中的所有问题，你就可以很轻松的应付任何核心 Java 或者高级 Java 面试。虽然，这里没有涵盖 Servlet、JSP、JSF、JPA，JMS，EJB 及其它 Java EE 技术，也没有包含主流的框架如 spring MVC，Struts 2.0，hibernate，也没有包含 SOAP 和 RESTful web service，但是这份列表对做 Java 开发的、准备应聘 Java web 开发职位的人还是同样有用的，因为所有的 Java 面试，开始的问题都是 Java 基础和 JDK API 相关的。如果你认为我这里有任何应该在这份列表中而被我遗漏了的 Java 流行的问题，你可以自由的给我建议。我的目的是从最近的面试中创建一份最新的、最优的 Java 面试问题列表。</p>
<h2 id="JDBC最佳实践"><a href="#JDBC最佳实践" class="headerlink" title="JDBC最佳实践"></a>JDBC最佳实践</h2><ul>
<li>优先使用批量操作来插入和更新数据</li>
<li>使用PreparedStatement来避免SQL漏洞</li>
<li>使用数据连接池</li>
<li>通过列名来获取结果集</li>
</ul>
<h2 id="IO操作最佳实践"><a href="#IO操作最佳实践" class="headerlink" title="IO操作最佳实践"></a>IO操作最佳实践</h2><ol>
<li>使用有缓冲的IO类,不要单独读取字节或字符</li>
<li>使用NIO和NIO 2或者AIO,而非BIO</li>
<li>在finally中关闭流</li>
<li>使用内存映射文件获取更快的IO</li>
</ol>

      
    </div>

    <div>
      
        
      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/面试/" rel="tag">#面试</a>
          
            <a href="/tags/java/" rel="tag">#java</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/02/20/GreenDao的使用以及一些细节的总结/" rel="next" title="GreenDao的使用以及一些细节的总结">
                <i class="fa fa-chevron-left"></i> GreenDao的使用以及一些细节的总结
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/03/01/hexo个人博客-如何在markdown上引用本地图片的地址？/" rel="prev" title="hexo个人博客-如何在markdown上引用本地图片的地址？">
                hexo个人博客-如何在markdown上引用本地图片的地址？ <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
          <div id="lv-container" data-id="city" data-uid="MTAyMC8yODQ1Mi81MDIz">
          </div>
    
  </div>



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/blog_head.jpg" alt="Mr.zeng">
          <p class="site-author-name" itemprop="name">Mr.zeng</p>
          <p class="site-description motion-element" itemprop="description">来这里，查看更多技术的分享</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">39</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">38</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">33</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java面试宝典"><span class="nav-number">1.</span> <span class="nav-text">Java面试宝典</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#相关概念"><span class="nav-number">2.</span> <span class="nav-text">相关概念</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#面向对象的三个特征"><span class="nav-number">2.1.</span> <span class="nav-text">面向对象的三个特征</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多态的好处"><span class="nav-number">2.2.</span> <span class="nav-text">多态的好处</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#代码中如何实现多态"><span class="nav-number">2.2.1.</span> <span class="nav-text">代码中如何实现多态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#虚拟机是如何实现多态的"><span class="nav-number">2.2.2.</span> <span class="nav-text">虚拟机是如何实现多态的</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#接口的意义"><span class="nav-number">2.3.</span> <span class="nav-text">接口的意义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#抽象类的意义"><span class="nav-number">2.4.</span> <span class="nav-text">抽象类的意义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#接口和抽象类的区别"><span class="nav-number">2.5.</span> <span class="nav-text">接口和抽象类的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#父类的静态方法能否被子类重写"><span class="nav-number">2.6.</span> <span class="nav-text">父类的静态方法能否被子类重写</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是不可变对象"><span class="nav-number">2.7.</span> <span class="nav-text">什么是不可变对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#能否创建一个包含可变对象的不可变对象"><span class="nav-number">2.8.</span> <span class="nav-text">能否创建一个包含可变对象的不可变对象?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java-创建对象的几种方式"><span class="nav-number">2.9.</span> <span class="nav-text">java 创建对象的几种方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#switch中能否使用string做参数"><span class="nav-number">2.10.</span> <span class="nav-text">switch中能否使用string做参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Object中有哪些公共方法"><span class="nav-number">2.11.</span> <span class="nav-text">Object中有哪些公共方法?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java当中的四种引用"><span class="nav-number">2.12.</span> <span class="nav-text">java当中的四种引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#WeakReference与SoftReference的区别"><span class="nav-number">2.13.</span> <span class="nav-text">WeakReference与SoftReference的区别?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么要有不同的引用类型"><span class="nav-number">2.14.</span> <span class="nav-text">为什么要有不同的引用类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java中-和eqauls-的区别-equals-和-hashcode的区别"><span class="nav-number">2.15.</span> <span class="nav-text">java中==和eqauls()的区别,equals()和`hashcode的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#a-hashCode-有什么用-与a-equals-b-有什么关系"><span class="nav-number">2.16.</span> <span class="nav-text">a.hashCode()有什么用?与a.equals(b)有什么关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#有没有可能两个不相等的对象有相同的hashcode"><span class="nav-number">2.17.</span> <span class="nav-text">有没有可能两个不相等的对象有相同的hashcode</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可以在hashcode中使用随机数字吗"><span class="nav-number">2.18.</span> <span class="nav-text">可以在hashcode中使用随机数字吗?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#“a-b”与a-equals-b-有什么区别"><span class="nav-number">2.19.</span> <span class="nav-text">“a==b”与a.equals(b)有什么区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-0-1-0-3返回值是什么"><span class="nav-number">2.20.</span> <span class="nav-text">3*0.1==0.3返回值是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#a-a-b与a-b有什么区别吗"><span class="nav-number">2.21.</span> <span class="nav-text">a=a+b与a+=b有什么区别吗?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内部类的作用"><span class="nav-number">2.22.</span> <span class="nav-text">内部类的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#final-finalize和finally的不同之处"><span class="nav-number">2.23.</span> <span class="nav-text">final,finalize和finally的不同之处</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#clone-是哪个类型的方法"><span class="nav-number">2.24.</span> <span class="nav-text">clone()是哪个类型的方法?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#深拷贝和浅拷贝的区别是什么"><span class="nav-number">2.25.</span> <span class="nav-text">深拷贝和浅拷贝的区别是什么?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#static都有哪些用法"><span class="nav-number">2.26.</span> <span class="nav-text">static都有哪些用法?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#final有哪些用法"><span class="nav-number">2.27.</span> <span class="nav-text">final有哪些用法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java中int-char-long各占多少字节"><span class="nav-number">2.28.</span> <span class="nav-text">java中int char,long各占多少字节?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#64位的JVM当中-int的长度是多少"><span class="nav-number">2.29.</span> <span class="nav-text">64位的JVM当中,int的长度是多少?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java-int和Integer的区别"><span class="nav-number">2.30.</span> <span class="nav-text">java int和Integer的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#int-和Integer谁占用的内存更多"><span class="nav-number">2.31.</span> <span class="nav-text">int 和Integer谁占用的内存更多?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#String-StringBuffer和StringBuilder区别"><span class="nav-number">2.32.</span> <span class="nav-text">String,StringBuffer和StringBuilder区别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#String和StringBuffer"><span class="nav-number">2.32.1.</span> <span class="nav-text">String和StringBuffer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#StringBuffer和StringBuilder"><span class="nav-number">2.32.2.</span> <span class="nav-text">StringBuffer和StringBuilder</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是编译器常量-使用它有什么风险"><span class="nav-number">2.33.</span> <span class="nav-text">什么是编译器常量?使用它有什么风险?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java当中使用什么类型表示价格比较好"><span class="nav-number">2.34.</span> <span class="nav-text">java当中使用什么类型表示价格比较好?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何将byte转为String"><span class="nav-number">2.35.</span> <span class="nav-text">如何将byte转为String</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可以将int强转为byte类型么-会产生什么问题"><span class="nav-number">2.36.</span> <span class="nav-text">可以将int强转为byte类型么?会产生什么问题?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关于垃圾回收"><span class="nav-number">2.37.</span> <span class="nav-text">关于垃圾回收</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#你知道哪些垃圾回收算法"><span class="nav-number">2.38.</span> <span class="nav-text">你知道哪些垃圾回收算法?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#调用System-gc-会发生什么"><span class="nav-number">2.39.</span> <span class="nav-text">调用System.gc()会发生什么?</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#进程-线程相关"><span class="nav-number">3.</span> <span class="nav-text">进程,线程相关</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#说说进程-线程-协程之间的区别"><span class="nav-number">3.1.</span> <span class="nav-text">说说进程,线程,协程之间的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#你了解守护线程吗-它和非守护线程有什么区别"><span class="nav-number">3.2.</span> <span class="nav-text">你了解守护线程吗?它和非守护线程有什么区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是多线程上下文切换"><span class="nav-number">3.3.</span> <span class="nav-text">什么是多线程上下文切换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建两种线程的方式-他们有什么区别"><span class="nav-number">3.4.</span> <span class="nav-text">创建两种线程的方式?他们有什么区别?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Runnable和Callable的区别"><span class="nav-number">3.5.</span> <span class="nav-text">Runnable和Callable的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么导致线程阻塞"><span class="nav-number">3.6.</span> <span class="nav-text">什么导致线程阻塞</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#wait-notify-和suspend-resume-之间的区别"><span class="nav-number">3.7.</span> <span class="nav-text">wait(),notify()和suspend(),resume()之间的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么wait-方法和notify-notifyAll-方法要在同步块中被调用"><span class="nav-number">3.8.</span> <span class="nav-text">为什么wait()方法和notify()/notifyAll()方法要在同步块中被调用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#wait-方法和notify-notifyAll-方法在放弃对象监视器时有什么区别"><span class="nav-number">3.9.</span> <span class="nav-text">wait()方法和notify()/notifyAll()方法在放弃对象监视器时有什么区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#wait-与sleep-的区别"><span class="nav-number">3.10.</span> <span class="nav-text">wait()与sleep()的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized和ReentrantLock的区别"><span class="nav-number">3.11.</span> <span class="nav-text">synchronized和ReentrantLock的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FutureTask是什么"><span class="nav-number">3.12.</span> <span class="nav-text">FutureTask是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一个线程如果出现了运行时异常怎么办"><span class="nav-number">3.13.</span> <span class="nav-text">一个线程如果出现了运行时异常怎么办?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何在两个线程间共享数据"><span class="nav-number">3.14.</span> <span class="nav-text">如何在两个线程间共享数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何正确的使用wait-使用if还是while"><span class="nav-number">3.15.</span> <span class="nav-text">如何正确的使用wait()?使用if还是while?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是线程局部变量"><span class="nav-number">3.16.</span> <span class="nav-text">什么是线程局部变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ThreadLoal的作用是什么"><span class="nav-number">3.17.</span> <span class="nav-text">ThreadLoal的作用是什么?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#生产者消费者模型的作用是什么"><span class="nav-number">3.18.</span> <span class="nav-text">生产者消费者模型的作用是什么?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#写一个生产者-消费者队列"><span class="nav-number">3.19.</span> <span class="nav-text">写一个生产者-消费者队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用阻塞队列来实现"><span class="nav-number">3.19.1.</span> <span class="nav-text">使用阻塞队列来实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用wait-notify来实现"><span class="nav-number">3.19.2.</span> <span class="nav-text">使用wait-notify来实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ConcurrentHashMap的并发度是什么"><span class="nav-number">3.20.</span> <span class="nav-text">ConcurrentHashMap的并发度是什么?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CyclicBarrier和CountDownLatch区别"><span class="nav-number">3.21.</span> <span class="nav-text">CyclicBarrier和CountDownLatch区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java中的-操作符线程安全么"><span class="nav-number">3.22.</span> <span class="nav-text">java中的++操作符线程安全么?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#你有哪些多线程开发良好的实践"><span class="nav-number">3.23.</span> <span class="nav-text">你有哪些多线程开发良好的实践?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可以创建Volatile数组吗"><span class="nav-number">3.24.</span> <span class="nav-text">可以创建Volatile数组吗?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#volatile能使得一个非原子操作变成原子操作吗"><span class="nav-number">3.25.</span> <span class="nav-text">volatile能使得一个非原子操作变成原子操作吗?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#volatile类型变量提供什么保证"><span class="nav-number">3.26.</span> <span class="nav-text">volatile类型变量提供什么保证?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java中的集合及其继承关系"><span class="nav-number">3.27.</span> <span class="nav-text">Java中的集合及其继承关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#poll-方法和remove-方法区别"><span class="nav-number">3.28.</span> <span class="nav-text">poll()方法和remove()方法区别?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LinkedHashMap和PriorityQueue的区别"><span class="nav-number">3.29.</span> <span class="nav-text">LinkedHashMap和PriorityQueue的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#WeakHashMap与HashMap的区别是什么"><span class="nav-number">3.30.</span> <span class="nav-text">WeakHashMap与HashMap的区别是什么?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ArrayList和LinkedList的区别"><span class="nav-number">3.31.</span> <span class="nav-text">ArrayList和LinkedList的区别?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ArrayList和HashMap默认大小"><span class="nav-number">3.32.</span> <span class="nav-text">ArrayList和HashMap默认大小?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Comparator和Comparable的区别"><span class="nav-number">3.33.</span> <span class="nav-text">Comparator和Comparable的区别?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何实现集合排序"><span class="nav-number">3.34.</span> <span class="nav-text">如何实现集合排序?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何打印数组内容"><span class="nav-number">3.35.</span> <span class="nav-text">如何打印数组内容</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LinkedList的是单向链表还是双向"><span class="nav-number">3.36.</span> <span class="nav-text">LinkedList的是单向链表还是双向?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TreeMap是实现原理"><span class="nav-number">3.37.</span> <span class="nav-text">TreeMap是实现原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#遍历ArrayList时如何正确移除一个元素"><span class="nav-number">3.38.</span> <span class="nav-text">遍历ArrayList时如何正确移除一个元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是ArrayMap-它和HashMap有什么区别"><span class="nav-number">3.39.</span> <span class="nav-text">什么是ArrayMap?它和HashMap有什么区别?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap的实现原理"><span class="nav-number">3.40.</span> <span class="nav-text">HashMap的实现原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#你了解Fail-Fast机制吗"><span class="nav-number">3.41.</span> <span class="nav-text">你了解Fail-Fast机制吗</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#关于日期"><span class="nav-number">4.</span> <span class="nav-text">关于日期</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#SimpleDateFormat是线程安全的吗"><span class="nav-number">4.1.</span> <span class="nav-text">SimpleDateFormat是线程安全的吗?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何格式化日期"><span class="nav-number">4.2.</span> <span class="nav-text">如何格式化日期?</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#关于异常"><span class="nav-number">5.</span> <span class="nav-text">关于异常</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#简单描述java异常体系"><span class="nav-number">5.1.</span> <span class="nav-text">简单描述java异常体系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是异常链"><span class="nav-number">5.2.</span> <span class="nav-text">什么是异常链</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#throw和throws的区别"><span class="nav-number">5.3.</span> <span class="nav-text">throw和throws的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关于序列化"><span class="nav-number">5.4.</span> <span class="nav-text">关于序列化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-中，Serializable-与-Externalizable-的区别"><span class="nav-number">5.5.</span> <span class="nav-text">Java 中，Serializable 与 Externalizable 的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM特性"><span class="nav-number">5.6.</span> <span class="nav-text">JVM特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#简单解释一下类加载器"><span class="nav-number">5.7.</span> <span class="nav-text">简单解释一下类加载器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#简述堆和栈的区别"><span class="nav-number">5.8.</span> <span class="nav-text">简述堆和栈的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#简述JVM内存分配"><span class="nav-number">5.9.</span> <span class="nav-text">简述JVM内存分配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java当中采用的是大端还是小端"><span class="nav-number">5.10.</span> <span class="nav-text">java当中采用的是大端还是小端?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#XML解析的几种方式和特点"><span class="nav-number">5.11.</span> <span class="nav-text">XML解析的几种方式和特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JDK-1-7特性"><span class="nav-number">5.12.</span> <span class="nav-text">JDK 1.7特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JDK-1-8特性"><span class="nav-number">5.13.</span> <span class="nav-text">JDK 1.8特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Maven和ANT有什么区别"><span class="nav-number">5.14.</span> <span class="nav-text">Maven和ANT有什么区别?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JDBC最佳实践"><span class="nav-number">5.15.</span> <span class="nav-text">JDBC最佳实践</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IO操作最佳实践"><span class="nav-number">5.16.</span> <span class="nav-text">IO操作最佳实践</span></a></li></ol></li></ol></div>
            
          </div>
        </section>
      
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=27955658&auto=0&height=66"></iframe>
    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mr.zeng</span>
</div>



<div class="theme-info">
  github地址-<a class="theme-link" href="https://github.com/iszengmh/">iszengmh</a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>
  

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>
  



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



   

    
      
    

   
        <!-- UY BEGIN -->
        <script type="text/javascript">
           (function(d, s) {
               var j, e = d.getElementsByTagName(s)[0];

               if (typeof LivereTower === 'function') { return; }

               j = d.createElement(s);
               j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
               j.async = true;

               e.parentNode.insertBefore(j, e);
           })(document, 'script');
        </script>
        <noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
        <!-- UY END -->
    
  





  



  
  
  

  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("p0KDi9bm8n854nHMDy73SpnU-gzGzoHsz", "Ub1cwWstEHmBqOqGoqlcY7G8");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

</body>

</html>
